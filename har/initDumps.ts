import { access } from 'node:fs/promises';
import { relative, resolve } from 'node:path';

import type { Page, TestInfo } from '@playwright/test';

export type InitDumpsOptions = {
    /**
     * Path to the root directory of the project, relative to which the calculation will be made
     * path to the dump directory (if not specified, the path is absolute)
     */
    rootPath?: string;

    /**
     * Mode of writing requests to a file instead of reading from it
     * @defaultValue `false`
     */
    update?: boolean;

    /**
     * Always update dumps if they are missing
     * @defaultValue `false`
     */
    forceUpdateIfHarMissing?: boolean;

    /**
     * Custom timeout for updating tests. Milliseconds.
     * Useful for long updates
     */
    updateTimeout?: number;

    /**
     * Operating mode for requests not found in the archive
     * @defaultValue `'abort'`
     */
    notFound?: 'abort' | 'fallback';

    /**
     * The address template of the requests to be processed
     */
    url?: string | RegExp;

    /**
     * Pack the result into an archive
     * @defaultValue `true`
     */
    zip?: boolean;

    /**
     * Custom path to the dump file. Overrides the path generated by dumpsPath.
     * @param params Parameters for constructing a path:
     * @param params.testInfo TestInfo information about the current test
     * @param params.zip Flag to use zip archive for .har
     *
     * @returns string path to dump file
     */
    dumpsFilePath?: (params: { testInfo: TestInfo; zip: boolean }) => string;
};

/**
 * Makes the necessary preparations for saving query dumps
 */
export async function initDumps(
    page: Page,
    testInfo: TestInfo,
    {
        dumpsFilePath: dumpsFilePathBuilder = defaultDumpsFilePathBuilder,
        rootPath,
        forceUpdateIfHarMissing = false,
        updateTimeout,
        notFound = 'abort',
        url,
        zip = true,
        update = false,
    }: InitDumpsOptions = {},
) {
    let harPath: string;

    harPath = dumpsFilePathBuilder({ testInfo, zip });

    if (rootPath) {
        harPath = relative(rootPath, harPath);
    }

    harPath = resolve(harPath);

    if (forceUpdateIfHarMissing) {
        try {
            await access(harPath);
        } catch {
            // eslint-disable-next-line no-param-reassign
            update = true;
        }
    }

    if (update && updateTimeout) {
        testInfo.setTimeout(updateTimeout);
    }

    console.info(update ? 'Write requests to' : 'Read requests from', harPath);

    await page.context().routeFromHAR(harPath, {
        update,
        notFound,
        url,
    });
}

function defaultDumpsFilePathBuilder({ testInfo, zip }: { testInfo: TestInfo; zip: boolean }) {
    const filePath = testInfo.snapshotPath(
        testInfo.titlePath
            .slice(1)
            .join('-')
            .replace(/ /g, '-')
            .replace(/[^a-zA-Z0-9\-_]/g, ''), // Removing characters which are not supported as filename
    );

    return zip ? `${filePath}.zip` : `${filePath}.har`;
}
