import { access } from 'node:fs/promises';
import { join, relative, resolve } from 'node:path';

import type { Page, TestInfo } from '@playwright/test';

import { getTestSlug } from '../actions';
import { extractTestSlug } from '../utils/extractTestSlug';

export type InitDumpsOptions = {
    /**
     * Path to the root directory of the project, relative to which the calculation will be made
     * path to the dump directory (if not specified, the path is absolute)
     */
    rootPath?: string;

    /**
     * Mode of writing requests to a file instead of reading from it
     * @defaultValue `false`
     */
    update?: boolean;

    /**
     * Always update dumps if they are missing
     * @defaultValue `false`
     */
    forceUpdateIfHarMissing?: boolean;

    /**
     * Custom timeout for updating tests. Milliseconds.
     * Useful for long updates
     */
    updateTimeout?: number;

    /**
     * Operating mode for requests not found in the archive
     * @defaultValue `'abort'`
     */
    notFound?: 'abort' | 'fallback';

    /**
     * The address template of the requests to be processed
     */
    url?: string | RegExp;

    /**
     * Pack the result into an archive
     * @defaultValue `true`
     */
    zip?: boolean;

    /**
     * User path to the directory with dumps. By default, the path is calculated as
     * testInfo.snapshotPath('').replace(/-snapshots\/[^/]+$/, '-data/' + slug)
     * @param testInfo TestInfo information about the current test
     * @param slug test slug
     *
     * @returns string path to the directory with dumps
     *
     * @deprecated use dumpsFilePath.
     */
    dumpsPath?: (testInfo: TestInfo, slug: string) => string;

    /**
     * Custom path to the dump file. Overrides the path generated by dumpsPath.
     * @param params Parameters for constructing a path:
     * @param params.testInfo TestInfo information about the current test
     * @param params.slug test slug
     * @param params.zip Flag to use zip archive for .har
     *
     * @returns string path to dump file
     */
    dumpsFilePath?: (params: { testInfo: TestInfo; slug: string; zip: boolean }) => string;
};

/**
 * Makes the necessary preparations for saving query dumps
 */
export async function initDumps(
    page: Page,
    testInfo: TestInfo,
    {
        dumpsPath: dumpsPathBuilder = defaultPathBuilder,
        dumpsFilePath: dumpsFilePathBuilder,
        rootPath,
        forceUpdateIfHarMissing = false,
        updateTimeout,
        notFound = 'abort',
        url,
        zip = true,
        update = false,
    }: InitDumpsOptions = {},
) {
    let slug: string;

    try {
        slug = getTestSlug(page);
    } catch (error) {
        console.warn(error);
        // Backward compatibility
        slug = extractTestSlug(testInfo.title, true);
    }

    let harPath: string;

    if (dumpsFilePathBuilder) {
        harPath = dumpsFilePathBuilder({ testInfo, slug, zip });
    } else {
        const dumpsPath = dumpsPathBuilder(testInfo, slug);

        harPath = join(dumpsPath, zip ? 'har.zip' : 'har.har');
    }

    if (rootPath) {
        harPath = relative(rootPath, harPath);
    }

    harPath = resolve(harPath);

    if (forceUpdateIfHarMissing) {
        try {
            await access(harPath);
        } catch {
            // eslint-disable-next-line no-param-reassign
            update = true;
        }
    }

    if (update && updateTimeout) {
        testInfo.setTimeout(updateTimeout);
    }

    console.info(update ? 'Write requests to' : 'Read requests from', harPath);

    await page.context().routeFromHAR(harPath, {
        update,
        notFound,
        url,
    });
}

function defaultPathBuilder(testInfo: TestInfo, slug: string) {
    return testInfo.snapshotPath('').replace(/-snapshots\/[^/]+$/, '-data/' + slug);
}
